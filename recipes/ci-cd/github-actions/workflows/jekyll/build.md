---
title: Build and deploy
description: Build a Jekyll site with GH Actions and then publish as a GH Pages site
---

{% raw %}

Related Cookbook pages:

- [GH Pages Actions][] page in this Jekyll section.
- [Deploy GH Pages][] as a more generic section which could still be used for Jekyll.
- [Jekyll container][] page.

[GH Pages Actions]: {{ site.baseurl }}{% link recipes/ci-cd/github-actions/workflows/jekyll/gh-pages-actions.md %}
[Deploy GH Pages]: {{ site.baseurl }}{% link recipes/ci-cd/github-actions/workflows/deploy-gh-pages/index.md %}
[Jekyll container]: {{ site.baseurl }}{% link recipes/containers/jekyll.md %}


## Why use GitHub Actions?

Note that if you setup a Jekyll site on GitHub, such as with a config and a homepage, GitHub can build the site and serve it for you. No GitHub Actions needed. And only one branch is needed.

That approach without GitHub Actions is much simpler. The downside is that you are forced to use the plugins and Jekyll version setup by GitHub. And you can't mix in Node or Python or whatever in your build flow. With GitHub Actions, you get control of that. Plus better logging on failed builds.


## Samples

In the examples below, there is a step to build the site with Jekyll and then a final step to serve the commit the `_site` directory to the `gh-pages` branch using an action. This keeps your source code on the main branch separate from the output site on the `gh-pages` branch. 

After you have a workflow building successfful, you can configure your repo's Settings to serve your `gh-pages` branch as a GitHub Pages site.

### Use Ruby action and Bundler

Here we setup a Ruby environment using the `setup-ruby` action. A param is passed to it so that it installed gems with Bundler and even caches them for you.

See the [GH Actions Ruby][] section for more info.

[GH Actions Ruby]: {{ site.baseurl }}{% recipes/ci-cd/github-actions/workflows/ruby/index.md %}

- `main.yml`
    ```yaml
    name: GH Pages deploy

    on:
      push:
        branches: main
        paths-ignore:
          - README.md

      pull_request:
        branches: main
        paths-ignore:
          - README.md

    jobs:
      build-deploy:
        name: Build and deploy

        runs-on: ubuntu-latest

        steps:
          - name: Checkout üõéÔ∏è
            uses: actions/checkout@v2

          - name: Setup Ruby üíé
            uses: ruby/setup-ruby@v1
            with:
              ruby-version: '2.7'
              bundler-cache: true

          - name: Build üèó
            run: bundle exec jekyll build --trace

          - name: Deploy to GH Pages üöÄ
            if: ${{ github.event_name != 'pull_request' }}
            uses: peaceiris/actions-gh-pages@v3
            with:
              github_token: ${{ secrets.GITHUB_TOKEN }}
              publish_dir: _site
    ```

Replace the Build command `make build` if you prefer.

Why use this this approach? This is a great generic approach, rather than being tied to using an action which is built around Jekyll or Jekyll + GH Pages. This Ruby action does the job well, it resusable across non-Jekyll projects and it will probably be simpler and better maintained than some Jekyll-specific one. Seeing as the Ruby one has wider appeal to community than a Jekyll solution.

### Jekyll in a container

This flow runs a **Docker container**

It has with Ruby and Jekyll inside container which is run as a binary (using `docker` CLI but no `Dockerfile` needed). So it can be used as a drop-in replacement for running `jekyll` directly. Plus the container takes care of Ruby and Jekyll dependencies and installing project dependencies. I end the workflow by deploy the `_site` directory generated by the build step as a GH Pages site.

- `main.yml`
    ```yaml
    name: GH Pages deploy

    on:
      push:
        branches: main
        paths-ignore:
          - README.md

      pull_request:
        branches: main
        paths-ignore:
          - README.md

    jobs:
      build-deploy:
        name: Build and deploy

        runs-on: ubuntu-latest

        steps:
          - name: Checkout üõéÔ∏è
            uses: actions/checkout@v2

          - name: Build Jekyll site
            run: |
              docker run \
                -v ${{ github.workspace }}:/srv/jekyll \
                jekyll/builder:4 \
                /bin/bash -c 'chmod 777 /srv/jekyll && jekyll build --future'
                
          - name: Deploy to GH Pages üöÄ
            if: ${{ github.event_name != 'pull_request' }}
            uses: peaceiris/actions-gh-pages@v3
            with:
              github_token: ${{ secrets.GITHUB_TOKEN }}
              publish_dir: _site
    ```

#### Links

See my Jekyll GH Actions Quickstart template project which demonstrates how to build a minimal site. It has a GH Actions flow which uses Docker + Jekyll in one step and GH Pages deploy in the last step.

- [![MichaelCurrin - jekyll-gh-actions-quickstart](https://img.shields.io/static/v1?label=MichaelCurrin&message=jekyll-gh-actions-quickstart&color=blue&logo=github)](https://github.com/MichaelCurrin/jekyll-gh-actions-quickstart)
- [Live demo](https://michaelcurrin.github.io/jekyll-gh-actions-quickstart/) website.

#### About the approach

This builds the site using a **Docker** container step. This means you don't need to use any Action from the marketplace to setup your Ruby and Jekyll environment. The container image is ready to go. When you run it, it will even install your gems for you using Bundler.

I think this is great - I don't know why there are so many Jekyll actions out there. Maybe if you really need control over the environment or build steps. Some actions include Jekyll and GH Pages in one - I don't think it is a good idea to mix those together in one inseparable step.

Another advantage is that you can run the exact same container locally - which is great for debugging and for running your application locally on any OS without requiring Ruby, Bundler and gems installed.

#### Notes on the workflow

- Using the Docker step alone output would get thrown away after the build. If you want to persist as a GH Pages site, just add on the last section as below, using a generic GH Pages action.
- You can pick a tag like `4` to get a recent version in `4.x` range. I'd avoid `latest` as one day you'll suddenly get `5`. GH Pages normally limits you to `3.9`.
- The `--future` flag is to publish futured-dated posts.

#### Original workflow

The workflow is based on the one generated by the GitHub when it suggests a Jekyll workflow for your project.

My additions:

- Use Jekyll version `4` instead of `latest` for more control.
- Add GH Pages at the end to persist on `gh-pages` branch. I've also setup this deploy step only runs on the main branch, not feature branches.

##### Permissions note

Note use of `chmod 777`. Otherwise you get an error that `Gemfile.lock` is not writeable.

##### Volume note

Note that GitHub's own starter workflow mounts **two** volumes, when only one is needed.

Here it is anyway with `_site` as a volume.

```
-v ${{ github.workspace }}:/srv/jekyll \
-v ${{ github.workspace }}/_site:/srv/jekyll/_site \
```

The second is unnecessary as it is already covered by the first as a nested directory with the identical name in and outside the container.

### Use the Jekyll Actions action

- [![limjh16 - jekyll-action-ts](https://img.shields.io/static/v1?label=limjh16&message=jekyll-action-ts&color=blue&logo=github)](https://github.com/limjh16/jekyll-action-ts)

This is fork of [Jekyll Actions](https://github.com/marketplace/actions/jekyll-actions) action, with the differences that the fork is built in TS not Docker and it doesn't to publish for you (the docs add a step for publishing) 

Which is great. As it means this Jekyll action has a narrow scope and it is also easy to add an extra step to publish to GH Pages. The docs recommend a popular action by PeaceIris, as shown in the last step below.

It appears you have to first setup Ruby and then use this Jekyll-related action.

This uses TypeScript instead of Docker, so is supposed should be quicker to download than the original action. It also is more flexible to handle non-default use-cases.

Sample usage based on the docs.

- `main.yml`
    ```yaml
    name: Build and deploy

    on:
      push:
        branches:
          - master

    jobs:
      jekyll:
        name: Build and deploy

        runs-on: ubuntu-latest

        steps:
          - name: Checkout üõé
            uses: actions/checkout@v2

          - name: Setup Ruby üíé
            uses: ruby/setup-ruby@v1
            with:
              ruby-version: 2.7

          - name: Install dependencies and build site üî®
            uses: limjh16/jekyll-action-ts@v2
            with:
              enable_cache: true

          - name: Deploy to GH Pages üöÄ
            if: ${{ github.event_name != 'pull_request' }}
            uses: peaceiris/actions-gh-pages@v3
            with:
              github_token: ${{ secrets.GITHUB_TOKEN }}
              publish_dir: _site
    ```

{% endraw %}
